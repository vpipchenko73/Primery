G = {
    "A": {
        "B": 7,
        "D":19},
    "B": {
        "A": 7,
        "C": 7,
        "A1": 18},
    "C": {
        "B": 7,
        "F": 6,
        "E": 18},
    "D": {
        "A": 19,
        "A1": 17},
    "A1": {
        "D": 17,
        "E": 15,
        "C1": 7,
        "B1": 14},
    "E": {
        "C": 18,
        "A1": 15},
    "F": {
        "C": 6,
        "C1": 1},
    "C1": {
        "F": 1,
        "A1": 7,
        "D1": 28},
    "B1": {
        "A1":14,
        "D1":25},
    "D1": {
        "B1": 25,
        "C1": 28}
}
# G = {
#     "A": {
#         "B": 5,
#         "C":12,
#         "D":7},
#     "B": {
#         "A": 5,
#         "E": 2},
#     "C": {
#         "A": 12,
#         "E": 4},
#     "D": {
#         "A": 7,
#         "E": 6},
#     "E": {
#         "B": 2,
#         "C": 4,
#         "D": 6},
# }
start='A'
end='D1'

D = {k : 100 for k in G.keys()}  # расстояния
start_k = start  # стартовая вершина
D[start_k] = 0  # расстояние от нее до самой себя равно нулю
U = {k : False for k in G.keys()}  # флаги просмотра вершин
P = {k : None for k in G.keys()}  # предки

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
            P[v] = min_k  # и записываем как предок
    U[min_k] = True  # просмотренную вершину помечаем

print(D)
print(P)

z=end
put=[z]
while z!=start:
    put.append(P[z])
    z=P[z]
#put.append(start)
print(f' короткий путь -> {put}')